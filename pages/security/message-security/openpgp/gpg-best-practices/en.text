@title = 'OpenPGP Best Practices'
@this.alias = 'best-practices'

h2. How to use this guide.

We have gathered here a lot of information about configuring GnuPG. There are detailed explanations for each configuration suggestion. Many of these changes require you to make changes to the GnuPG configuration file on your machine located at @~/.gnupg/gpg.conf@.

This guide was originally written for legacy versions of GnuPG (1.4) and [[has been updated -> https://github.com/riseupnet/riseup_help/issues/451]] for GnuPG v2.1. If you have ideas how to improve it, you can help by [[submitting changes->https://github.com/riseupnet/riseup_help/edit/master/pages/security/message-security/openpgp/gpg-best-practices/en.text]] yourself.

h2. Use free software, and keep it updated.

Information security is too important to leave to proprietary software. You should use a free OpenPGP implementation, and keep it up-to-date. The canonical free OpenPGP implementation is [[GnuPG -> https://gnupg.org/]], and it is available for every major modern operating system. It is not enough to install GnuPG and forget about it, though. You *must* keep it up to date so that critical security flaws are fixed. All software has bugs, and GnuPG is no exception. If you are running:

- GNU/Linux (Debian, Ubuntu, Mint, Fedora, etc) := your operating system will install GnuPG automatically and keep it up to date for you.
- Windows := you can install [[Gpg4win -> https://gpg4win.org/]] and [[subscribe to gpg4win-announce -> https://lists.wald.intevation.org/mailman/listinfo/gpg4win-announce]] to know when to update.
- macOS := you can install [[GPG suite from GPGTools -> https://gpgtools.org/]]. The suite will let you know when there is an update available, or you can follow their [[twitter -> https://twitter.com/GPGTools]].
- Building from source for any other operating system := you should [[subscribe to gnupg-announce -> https://lists.gnupg.org/mailman/listinfo/gnupg-announce]] to know when you should update.

h2. Selecting a keyserver and configuring your machine to refresh your keyring.

If you do not regularly refresh your public keys, you do not get timely expirations or revocations, both of which are very important to be aware of! There are two components to receiving key updates. Many users send their key updates to keyservers. In order to receive these updates, you must first ensure that you are using a keyserver that is functioning properly (default since 2.1). Then, you have to configure your machine to receive key updates in a regular fashion (run @gpg --refresh-keys@ from time to time).

[[Since GnuPG v2.1 -> https://www.gnupg.org/faq/whats-new-in-2.1.html#ecc]], [[dirmngr -> https://www.gnupg.org/documentation/manuals/gnupg/Invoking-DIRMNGR.html#Invoking-DIRMNGR]] takes care of accessing the OpenPGP keyservers. As with previous versions it is also used as a server for managing [[X.509 certificates -> secure-connections]] and access to OCSP providers. Dirmngr is invoked internally by gpg, gpgsm, or via the gpg-connect-agent tool and can be stopped without harm.

To see the list of keyservers used by dirmngr enter into a terminal:
@gpg-connect-agent --dirmngr 'keyserver --hosttable' /bye@

If you want to remove a dead host or want to learn about the dirmngr's keyserver functionality, see the [[dirmngr usage examples -> https://www.gnupg.org/documentation/manuals/gnupg/Dirmngr-Examples.html#Dirmngr-Examples]].

h3. Note for gnupg prior 2.1

Since version 2.1.11 Gnupg installs the CA certificate for hkps.pool.sks-keyservers.net and uses it by default. If you are using an up to date version (check with @gpg --version@), you can [[skip this section -> #ensure-that-all-keys-are-refreshed-through-the-keyserver-you-have-selected]].

bq. It is strongly recommended to upgrade your installation of gnupg for security reasons. Unfortunately some users are stuck with gpg 1 because their distribution requires it for some tools, but use gpg 2.1 in parallel. In this case the best option is to upgrade or switch the distribution, because a lot of security relevant fixes need to be backported, to keep older versions secure.

h4. Use the sks keyservers pool

Previous versions of gnupg come configured with a single, specific keyserver. This is not ideal because if the keyserver fails, or even worse, if it appears to work but is not functioning properly, you may not receive critical key updates. Not only is this a single point of failure, it is also a prime source of leaks of relationship information between OpenPGP users, and thus an attack target.

The machines in this pool have regular health checks to ensure that they are functioning properly. If a server is not working well, it will be removed automatically from the pool.

Therefore, we recommend using the [[sks keyservers pool -> https://sks-keyservers.net/overview-of-pools.php]]. The machines in this pool have regular health checks to ensure that they are functioning properly. If a server is not working well, it will be removed automatically from the pool.

You should also ensure that you are communicating with the keyserver pool over an encrypted channel, using a protocol called hkps. The transport encryption is important because if you do a @gpg --refresh-keys@ on a keyserver that is hkp only, then someone snooping your traffic will see every single key you have in your key ring as you request any updates to them. That is pretty interesting information. In order to use hkps, you need to install gnupg-curl (on debian: @sudo apt-get install gnupg-curl@).

Then, to use this keyserver pool, you will need to [[download the sks-keyservers.net CA -> https://sks-keyservers.net/sks-keyservers.netCA.pem]], and save it somewhere on your machine. Please remember the path that you save the file to. Next, you should verify the certificate's fingerprint. Inspect the X509v3 Subject Key Identifier with

bc. curl -sSL https://sks-keyservers.net/sks-keyservers.netCA.pem | openssl x509 -in - -noout -text | grep "X509v3 Subject Key Identifier" -A1 | tail -n1 | tr -d ' '

and compare-it with the X509 fingerprint written on the [[pool website-> https://sks-keyservers.net/verify_tls.php]]. It has a signature to verify the .pem file:

bc. curl -sSL https://sks-keyservers.net/sks-keyservers.netCA.pem -o sks-keyservers.netCA.pem
curl -sSL https://sks-keyservers.net/sks-keyservers.netCA.pem.asc -o sks-keyservers.netCA.pem.asc
openssl verify -trusted sks-keyservers.netCA.pem -check_ss_sig sks-keyservers.netCA.pem

It should output: @sks-keyservers.netCA.pem: OK@. See also [[howto check the signature of files -> https://www.torproject.org/docs/verifying-signatures.html.en]].

To verify that the certificate file was downloaded correctly, you can verify the OpenPGP signature:

bc. gpg --auto-key-retrieve --verify sks-keyservers.netCA.pem.asc

The option [[@--auto-key-retrieve@ -> https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#GPG-Configuration-Options]] will automatically import keys used to create the signature. Make sure that the output looks like

bc. gpg: assuming signed data in 'sks-keyservers.netCA.pem'
gpg: Signature made Wed Mar 30 17:06:29 2016 CEST
gpg:                using RSA key 0x250B7AFED6379D85
gpg: Good signature from "Kristian Fiskerstrand <kristian.fiskerstrand@sumptuouscapital.com>" [unknown]
gpg:                 aka "Kristian Fiskerstrand <kf@gnupg.net>" [unknown]
gpg:                 aka "Kristian Fiskerstrand <k_f@gentoo.org>" [unknown]
gpg:                 aka "Kristian Fiskerstrand <kf@sumptuouscapital.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 94CB AFDD 3034 5109 5618  35AA 0B7F 8B60 E3ED FAE3
     Subkey fingerprint: B4EA D120 C7F8 9A4A EA47  2707 250B 7AFE D637 9D85

Congratiolations, you confirmed that you are in possession of an uncorrupted copy of the correct certificate file for the keyserver pool. If you liked that procedure, have a look at [[Riseup's certificates page->certificates]].

Now, you will need to use the following parameters in @~/.gnupg/gpg.conf@, and specify the full path where you saved the .pem file above by defining the _ca-cert-file_ option:

@keyserver-options ca-cert-file=/path/to/CA/sks-keyservers.netCA.pem@

Note: Gnupg 2.1 will complain about this option:

@gpg: keyserver option 'ca-cert-file' is obsolete; please use 'hkp-cacert' in dirmngr.conf@

The [[dirmngr option->https://www.gnupg.org/documentation/manuals/gnupg/Dirmngr-Options.html#Dirmngr-Options]] 'hkp-cacert' is supported since gnugpg 2.1.

h3. Ensure that all keys are refreshed through the keyserver you have selected.

When creating a key, individuals may designate a specific keyserver to use to pull their keys from. It is recommended that you use the following option to @~/.gnupg/gpg.conf@, which will ignore such designations:

bc. keyserver-options no-honor-keyserver-url

This is useful because (1) it prevents someone from designating an insecure method for pulling their key and (2) if the server designated uses hkps, the refresh will fail because the ca-cert will not match, so the keys will never be refreshed. Note also that an attacker could designate a keyserver that they control to monitor when or from where you refresh their key.

h3. Refresh your keys slowly and one at a time.

Now that you have configured a good keyserver, you need to make sure that you are regularly refreshing your keys.

The command @gpg --keyserver-options no-honor-keyserver-url --refresh-keys@ is the equivalent to above setting, however you should not use it (similarly the 'refresh keys' menu item in your email client), because you disclose to the keyserver operator the whole set of keys that you are interested in refreshing. From the [[gnupg documentation -> https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#GPG-Configuration-Options]] for @--auto-key-retrieve@:

bq. Note that this option makes a "web bug" like behavior possible. Keyserver or Web Key Directory operators can see which keys you request, so by sending you a message signed by a brand new key (which you naturally will not have on your local keyring), the operator can tell both your IP address and the time when you verified the signature.

Therefore it is a good idea, to [[torify GnuPG requests -> https://trac.torproject.org/projects/tor/wiki/doc/TorifyHOWTO/GnuPG]]: Check that @use-tor@ is present in @~/.gnupg/dirmngr.conf@ (it is default since GnuPG v2.1).

Until GnuPG offers [[this option -> https://dev.gnupg.org/T1235]], you can add following script to your cronjobs:

.bc #!/bin/bash
# refreshes gpg keys one by one with a random time interval
while true
do
  for fingerprint in $(gpg --list-keys --with-colons --with-fingerprint | grep --after-context "1" "^pub" | grep "^fpr" | cut -d ":" -f "10" | sort --random-sort)
  do
    sleep $(( (RANDOM % 1000) + 300))
    gpg --batch --no-tty --no-auto-check-trustdb --refresh-keys "$fingerprint" 2> /dev/null
  done
done &

h4. Troubleshooting dirmngr

Whenever you have the impression that "No data" is an incorrect answer when performing a @gpg --search KEYID@, it is safe to run @dirmngr --shutdown@. It will be restarted automatically when it is needed.

If it gives 'error: searching keyserver: server indicated a failure', re-start tor (if used), dirmngr and gpg-agent (by sending KILLAGENT to gpg-connect-agent). It will get things back to the way they were.

There are some known issues with the included libdns and fixes have been pushed to master very recently, they'll be in v2.2.9.

To relaunch it run it with whatever flags you normally use (if any). Another option is to run: @gpg-connect-agent@, it starts an interactive interface, then enter @KILLAGENT@ and press Ctrl-D to stop it. On debian based systems you can restart it with @systemctl --user restart dirmngr.socket@ and @gpgconf --kill gpg-agent@.

h3. Do not blindly trust keys from keyservers.

Anyone can upload keys to keyservers and there is no reason that you should trust that any key you download actually belongs to the individual listed in the key. You should therefore verify with the individual owner the full key fingerprint of their key. You should do this verification in real life or over the phone.

Once you have verified the key fingerprint that you need, you may download the key from the keyserver pool:

bc. gpg --recv-key '<fingerprint>'

The next step is to confirm that you actually got the correct key from the keyserver. The keyserver might have given you a different key than the one you just asked for. If you have gpg with version less than 2.1, then you must manually confirm the fingerprint after you have downloaded the key (versions 2.1 and later will refuse to accept incorrect keys from the keyserver).

You can confirm the key fingerprint in one of two ways:

Option 1. Check the fingerprint is now in your keyring:

bc. gpg --fingerprint '<fingerprint>'

Option 2. Attempt to (locally) sign a key with that fingerprint:

bc. gpg --lsign-key '<fingerprint>'

If you are confident you have the right fingerprint from the owner of the key, the preferred method is to locally sign the key. If you want to publicly advertise your connection to the person who owns the key, you can do a publicly exportable [@--sign-key@] instead.

Note the single quote marks above ('), which should surround your full fingerprint and are necessary to make this command work. Double-quotes (") also work.

h3. Don't rely on the Key ID.

Short OpenPGP Key IDs, for example 0x2861A790, are 32 bits long. They have been [[shown -> https://www.asheesh.org/note/debian/short-key-ids-are-bad-news.html]] to be easily spoofed by another key with the same Key ID. Long OpenPGP Key IDs (for example 0xA1E6148633874A3D) are 64 bits long. They are [[trivially collidable -> http://thread.gmane.org/gmane.ietf.openpgp/7413]], which is [[also a potentially serious problem -> https://www.debian-administration.org/users/dkg/weblog/105]].

If you want to deal with a cryptographically-strong identifier for a key, you should use the full fingerprint. You should _never_ rely on the short, or even long, Key ID.

You should probably at least set @keyid-format 0xlong@ and @with-fingerprint@ gpg options (put them in @~/.gnupg/gpg.conf@) to increase the Key ID display size to 64-bit under regular use, and to always display the fingerprint.

Note that there was a [[bug in enigmail ->https://sourceforge.net/p/enigmail/bugs/239/]], which is fixed in version 1.7.0: If you add the option 'with-fingerprint' to display full fingerprints when listing keys, the fingerprint that is displayed in the enigmail key management window will be that of a subkey rather than the fingerprint of the primary key. You can always find your primary key's fingerprint (for example, if you want to give your fingerprint to someone to verify at a keysigning party), you can display the fingerprints of all of your secret keys by running this:

bc. gpg --with-fingerprint --list-secret-key

h3. Check key fingerprints before importing.

If you received or downloaded a key in a <keyfile>, you can and should display its fingerprint before importing it into your keyring, in that way you can verify the fingerprint without possibly spoiling your keyring and adding a compromised key:

pre. gpg --with-fingerprint <keyfile>

h2. Key configuration

Now that you know how to receive regular key updates from a well-maintained keyserver, you should make sure that your OpenPGP key is optimally configured. Many of these changes may require you to generate a new key. [[Read on->gpg-keys#key-configuration]]

h2. Additional suggestions.

h3. Consider using an ECC subkey

Since gnupg 2.1 ECC subkeys are supported.

They are faster, which is very useful for security tokens. Note, if there both a RSA and ECC key available, GnuPG will do the right thing and choose the one that works (e.g. use RSA if it doesn't support ECC).

For details see the [[official FAQ->https://www.gnupg.org/faq/whats-new-in-2.1.html#ecc]].

h3. Do you have an encrypted backup of your secret key material?

Double check on it.

h3. Do not include a "Comment" in your User ID.

If you think you need a "Comment" field in your OpenPGP User ID [[please think long and hard before deciding that is really the case -> https://www.debian-administration.org/users/dkg/weblog/97]]. You probably don't need or want it, and having a comment field makes it harder for people to know what they're certifying.
