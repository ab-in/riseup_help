@title = 'OpenPGP Best Practices'
@this.alias = 'best-practices'

h2. How to use this guide.

We have gathered here a lot of information about configuring GnuPG. There are detailed explanations for each configuration suggestion. Many of these changes require you to make changes to the GnuPG configuration file on your machine located at @~/.gnupg/gpg.conf@.

Also note that this guide was written for legacy versions of GnuPG (1.4) and may contain recommendations that are redundant with default settings in newer releases of GnuPG (2.1 and above). A [[review is in progress->https://github.com/riseupnet/riseup_help/issues/451]] to make sure the guide is up to date. You can help by [[submitting changes->https://github.com/riseupnet/riseup_help/edit/master/pages/security/message-security/openpgp/gpg-best-practices/en.text]] yourself.

h2. Use free software, and keep it updated.

Information security is too important to leave to proprietary software. You should use a free OpenPGP implementation, and keep it up-to-date. The canonical free OpenPGP implementation is [[GnuPG -> https://gnupg.org/]], and it is available for every major modern operating system. It is not enough to install GnuPG and forget about it, though. You *must* keep it up to date so that critical security flaws are fixed. All software has bugs, and GnuPG is no exception. If you are running:

- GNU/Linux (Debian, Ubuntu, Mint, Fedora, etc) := your operating system will install GnuPG automatically and keep it up to date for you.
- Windows := you can install [[Gpg4win -> https://gpg4win.org/]] and [[subscribe to gpg4win-announce -> https://lists.wald.intevation.org/mailman/listinfo/gpg4win-announce]] to know when to update.
- macOS := you can install [[GPG suite from GPGTools -> https://gpgtools.org/]]. The suite will let you know when there is an update available, or you can follow their [[twitter -> https://twitter.com/GPGTools]].
- Building from source for any other operating system := you should [[subscribe to gnupg-announce -> https://lists.gnupg.org/mailman/listinfo/gnupg-announce]] to know when you should update.

h2. Selecting a keyserver and configuring your machine to refresh your keyring.

If you do not regularly refresh your public keys, you do not get timely expirations or revocations, both of which are very important to be aware of! There are two components to receiving key updates. Many users send their key updates to keyservers. In order to receive these updates, you must first ensure that you are using a keyserver that is functioning properly. Then, you have to configure your machine to receive key updates in a regular fashion.

[[Since version 2.1 of GnuPG -> https://www.gnupg.org/faq/whats-new-in-2.1.html#ecc]], [[dirmngr -> https://www.gnupg.org/documentation/manuals/gnupg/Invoking-DIRMNGR.html#Invoking-DIRMNGR]] takes care of accessing the OpenPGP keyservers. As with previous versions it is also used as a server for managing and downloading certificate revocation lists (CRLs) for X.509 certificates, downloading X.509 certificates, and providing access to OCSP providers. Dirmngr is invoked internally by gpg, gpgsm, or via the gpg-connect-agent tool.

To see the list of keyservers used by dirmngr enter into a terminal:
@gpg-connect-agent --dirmngr 'keyserver --hosttable' /bye@

If you want to remove a dead host or want to learn about the dirmngr's keyserver functionality, see the [[dirmngr usage examples -> https://www.gnupg.org/documentation/manuals/gnupg/Dirmngr-Examples.html#Dirmngr-Examples]].

h3. Note for gnupg prior 2.1

In previous version it was necessary to define a _ca-cert-file_ option:

@keyserver-options ca-cert-file=/path/to/CA/sks-keyservers.netCA.pem@

Unfortunately some users are stuck with gpg 1 because their distribution requires it for some tools, but use gpg 2.1 in parallel. In this case following warning may occure and may be ignored:

@gpg: keyserver option 'ca-cert-file' is obsolete; please use 'hkp-cacert' in dirmngr.conf@

By default, from version 2.1.11, Gnupg installs the CA certificate for hkps.pool.sks-keyservers.net and make use of it by default, which means rolling linux distributions will not have problems not setting the hkp-cacert config option.

The [[dirmngr option->https://www.gnupg.org/documentation/manuals/gnupg/Dirmngr-Options.html#Dirmngr-Options]] 'hkp-cacert' is supported since gnugpg 2.1.

h3. Use the sks keyserver pool, instead of one specific server, with secure connections.

bq. Note that this is the default starting with GnuPG 2.1.18 (at least).

Most OpenPGP clients come configured with a single, specific keyserver. This is not ideal because if the keyserver fails, or even worse, if it appears to work but is not functioning properly, you may not receive critical key updates. Not only is this a single point of failure, it is also a prime source of leaks of relationship information between OpenPGP users, and thus an attack target.

The machines in this pool have regular health checks to ensure that they are functioning properly. If a server is not working well, it will be removed automatically from the pool.

Therefore, we recommend using the [[sks keyservers pool -> https://sks-keyservers.net/overview-of-pools.php]] over an encrypted channel, using a protocol called hkps.

The transport encryption is important because if you do a @gpg --refresh-keys@ on a keyserver that is hkp only, then someone snooping your traffic will see every single key you have in your key ring as you request any updates to them. That is pretty interesting information.

h3. Ensure that all keys are refreshed through the keyserver you have selected.

When creating a key, individuals may designate a specific keyserver to use to pull their keys from. It is recommended that you use the following option to @~/.gnupg/gpg.conf@, which will ignore such designations:

bc. keyserver-options no-honor-keyserver-url

This is useful because (1) it prevents someone from designating an insecure method for pulling their key and (2) if the server designated uses hkps, the refresh will fail because the ca-cert will not match, so the keys will never be refreshed. Note also that an attacker could designate a keyserver that they control to monitor when or from where you refresh their key.

h3. Refresh your keys slowly and one at a time.

Now that you have configured a good keyserver, you need to make sure that you are regularly refreshing your keys. The best way to do this on Debian and Ubuntu is to use parcimonie:

bc. sudo apt-get install parcimonie

[[Parcimonie-> https://gaffer.ptitcanardnoir.org/intrigeri/code/parcimonie/]] is a daemon that slowly refreshes your keyring from a keyserver over [[Tor --> https://www.torproject.org/]]. It uses a randomized sleep, and fresh Tor circuits for each key. The purpose is to make it hard for an attacker to correlate the key updates with your keyring.

You should *not* use @gpg --refresh-keys@ or the refresh keys menu item on your email client because you disclose to anyone listening, and the keyserver operator, the whole set of keys that you are interested in refreshing.

h4. Troubleshooting dirmng

It is a known error, that parcimonie fails with at least gnupg 2.2.8:

bc. gpg: keyserver receive failed: No data
 at /usr/share/perl5/App/Parcimonie/Daemon.pm line 350

Whenever you have the impression that "No data" is incorrect when performing a @gpg --search KEYID@, it is safe to run @dirmngr --shutdown@. It will be restarted automatically when it is needed.

If it gives 'error: searching keyserver: server indicated a failure', re-start tor (if used), dirmngr and gpg-agent (by sending KILLAGENT to gpg-connect-agent). It will get things back to the way they were.

There are some known issues with the libdns included and fixes have been pushed to master very recently, they'll be in 2.2.9.

To relaunch it run it with whatever flags you normally use (if any). Another option is to run: @gpg-connect-agent@, it starts an interactive interface, then enter @KILLAGENT@ and press Ctrl-D to stop it. On debian based systems you can restart it with @systemctl --user restart dirmngr.socket@ and @gpgconf --kill gpg-agent@.

h3. Do not blindly trust keys from keyservers.

Anyone can upload keys to keyservers and there is no reason that you should trust that any key you download actually belongs to the individual listed in the key. You should therefore verify with the individual owner the full key fingerprint of their key. You should do this verification in real life or over the phone.

Once you have verified the key fingerprint that you need, you may download the key from the keyserver pool:

bc. gpg --recv-key '<fingerprint>'

The next step is to confirm that you actually got the correct key from the keyserver. The keyserver might have given you a different key than the one you just asked for. If you have gpg with version less than 2.1, then you must manually confirm the fingerprint after you have downloaded the key (versions 2.1 and later will refuse to accept incorrect keys from the keyserver).

You can confirm the key fingerprint in one of two ways:

Option 1. Check the fingerprint is now in your keyring:

bc. gpg --fingerprint '<fingerprint>'

Option 2. Attempt to (locally) sign a key with that fingerprint:

bc. gpg --lsign-key '<fingerprint>'

If you are confident you have the right fingerprint from the owner of the key, the preferred method is to locally sign the key. If you want to publicly advertise your connection to the person who owns the key, you can do a publicly exportable [@--sign-key@] instead.

Note the single quote marks above ('), which should surround your full fingerprint and are necessary to make this command work. Double-quotes (") also work.

h3. Don't rely on the Key ID.

Short OpenPGP Key IDs, for example 0x2861A790, are 32 bits long. They have been [[shown -> https://www.asheesh.org/note/debian/short-key-ids-are-bad-news.html]] to be easily spoofed by another key with the same Key ID. Long OpenPGP Key IDs (for example 0xA1E6148633874A3D) are 64 bits long. They are [[trivially collidable -> http://thread.gmane.org/gmane.ietf.openpgp/7413]], which is [[also a potentially serious problem -> https://www.debian-administration.org/users/dkg/weblog/105]].

If you want to deal with a cryptographically-strong identifier for a key, you should use the full fingerprint. You should _never_ rely on the short, or even long, Key ID.

You should probably at least set @keyid-format 0xlong@ and @with-fingerprint@ gpg options (put them in @~/.gnupg/gpg.conf@) to increase the Key ID display size to 64-bit under regular use, and to always display the fingerprint.

Note that there was a [[bug in enigmail ->https://sourceforge.net/p/enigmail/bugs/239/]], which is fixed in version 1.7.0: If you add the option 'with-fingerprint' to display full fingerprints when listing keys, the fingerprint that is displayed in the enigmail key management window will be that of a subkey rather than the fingerprint of the primary key. You can always find your primary key's fingerprint (for example, if you want to give your fingerprint to someone to verify at a keysigning party), you can display the fingerprints of all of your secret keys by running this:

bc. gpg --with-fingerprint --list-secret-key

h3. Check key fingerprints before importing.

If you received or downloaded a key in a <keyfile>, you can and should display its fingerprint before importing it into your keyring, in that way you can verify the fingerprint without possibly spoiling your keyring and adding a compromised key:

pre. gpg --with-fingerprint <keyfile>

h2. Key configuration

Now that you know how to receive regular key updates from a well-maintained keyserver, you should make sure that your OpenPGP key is optimally configured. Many of these changes may require you to generate a new key. [[Read on->gpg-keys#key-configuration]]

h2. Additional suggestions.

h3. Consider using an ECC subkey

Since gnupg 2.1 ECC subkeys are supported.

They are faster, which is very useful for security tokens. Note that if there's a RSA and ECC key on a key, GnuPG 1.4 will do the right thing and choose the one that works (e.g. use RSA if it doesn't support ECC).

For details see the [[official FAQ->https://www.gnupg.org/faq/whats-new-in-2.1.html#ecc]].

h3. Do you have an encrypted backup of your secret key material?

Double check on it.

h3. Do not include a "Comment" in your User ID.

If you think you need a "Comment" field in your OpenPGP User ID [[please think long and hard before deciding that is really the case -> https://www.debian-administration.org/users/dkg/weblog/97]]. You probably don't need or want it, and having a comment field makes it harder for people to know what they're certifying.
