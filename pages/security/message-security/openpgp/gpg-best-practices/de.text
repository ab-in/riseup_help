@title = 'OpenPGP: optimales Vorgehen'

h2. Über diese Anleitung

Wir haben hier eine Menge Informationen zur Konfiguration von OpenPGP zusammengetragen. Zu jeder Konfigurationsempfehlung gibt es ausführliche Erläuterungen. Für viele dieser Empfehlungen sind Änderungen an der Konfigurationsdatei von gnupg auf Deinem Rechner erforderlich, die sich in @~/.gnupg/gpg.conf@ befindet.

Diese Anleitung wurde ursprünglich für eine ältere Version von GnuPG (1.4) geschrieben und wurde für GnuPG v2.1 [[aktualisiert -> https://github.com/riseupnet/riseup_help/issues/451]]. Du kannst dabei helfen, sie weiter zu verbessern [[durch Einsenden von Änderungsvorschlägen->https://github.com/riseupnet/riseup_help/edit/master/pages/security/message-security/openpgp/gpg-best-practices/en.text]].

h2. Freie Software verwenden und auf dem neusten Stand halten

Informationssicherheit is zu wichtig, um sie kommerzieller Software zu überlassen. Du solltest eine freie OpenPGP-Implementierung verwenden und auf dem neuesten Stand halten. Die Standardlösung für freies OpenPGP ist [[GnuPG -> https://gnupg.org/]] und es ist für alle gängigen, modernen Betriebssyteme verfügbar. Es reicht aber nicht GnuPG einfach zu installieren und dann nie wieder darüber nachzudenken. Du *musst* die Software auch aktuell halten, damit kritische Sicherheitslücken behoben werden können. Jede Software hat Fehler und GnuPG ist keine Ausnahme. Je nach Betriebssystem gibt es dies zu beachten:

* *GNU/Linux* (Debian, Ubuntu, Mint, Fedora, usw.): Dein Betriebssystem installiert GnuPG automatisch und hält es auch auf dem neuesten Stand.
* Windows: Du kannst "Gpg4win":https://gpg4win.org/index-de.html installieren und die "gpg4win-announce Mailingliste":https://lists.wald.intevation.org/mailman/listinfo/gpg4win-announce (englisch) abonnieren, um herauszufinden wann es Zeit ist ein Update zu installieren.
* *Mac OS*: Du kannst die "GPG Suite von GPGTools":https://gpgtools.org installieren.
* Wenn Du den Quellcode selbst übersetzt (z.B. für andere Betriebssysteme), solltest du die "gnupg-announce Mailingliste":https://lists.gnupg.org/mailman/listinfo/gnupg-announce abonnieren, um herauszufinden wann es Zeit ist ein Update zu installieren.

h2. Einen Schlüsselserver auswählen und den eigenen Rechner so konfigurieren, dass der Schlüsselbund aktualisiert wird.

Wenn öffentliche Schlüssel nicht regelmäßig aktualisiert werden, kann es sein, dass an inzwischen zurückgezogene Schlüssel verschlüsselt wird, oder ein lokal abgelaufener Schlüssel auf dem Schlüsselserver verlängert wurde. Beim Aktualisieren von Schlüsseln sind zwei Aspekte zu berücksichtigen: Aktualisierungen werden oft auf Schlüsselservern gespeichert. Also müssen gut funktionierende Schlüsselserver verwendet werden (dies ist Standard seit GnuPG v2.1). Dann musst Du Deinen Rechner so konfigurieren, dass er regelmäßig Schlüsselupdates bekommt (regelmäßig @gpg --refresh-keys@ ausführen).

[[Seit GnuPG v2.1-> https://www.gnupg.org/faq/whats-new-in-2.1.html#ecc]] übernimmt [[dirmngr -> https://www.gnupg.org/documentation/manuals/gnupg/Invoking-DIRMNGR.html#Invoking-DIRMNGR]] die Kommunikation mit OpenPGP Schlüsselservern. Wie bereits in vorherigen Versionen wird es auch zum Herunterladen von Widerrufslisten (CRL) für [[X.509-Zertifikate -> secure-connections]] und die Kommunikation mit OCSP-Anbietern benutzt. Dirmngr wird intern von gpg, gpgsm, oder gpg-connect-agent gestartet und kann ohne Folgen gestoppt werden.

Um die Liste von gpg verwendeter Schlüsselserver zu sehen, gib folgenden Befehl in ein Terminal ein:
@gpg-connect-agent --dirmngr 'keyserver --hosttable' /bye@

Um einen bestimmten Server zu entfernen, z.B. weil er nicht mehr antwortet, oder um weitere Interaktionsmöglichkeiten zu erfahren, siehe [[dirmngr-Beispiele -> https://www.gnupg.org/documentation/manuals/gnupg/Dirmngr-Examples.html#Dirmngr-Examples]].

h3. Hinweis für GnuPG vor v2.1

Seit Version 2.1 bringt GnuPG das Zertifikat von hkps.pool.sks-keyservers.net mit und verwendet diesen standardmäßig. Falls gpg aktuell ist (@gpg --version), [[überspringe diesen Abschnitt -> #]].

bq. Wir empfehlen Dir sehr, GnuPG zu aktualisieren. Manche Distributionen benutzen intern ältere Versionen, aber haben eine neuere Version installiert. In diesem Falle solltest Du die Distribution aktualisieren oder wechseln, denn viele sicherheitsrelevante Verbesserungen der Einstellungen müssen von Hand gemacht werden.

h4. Benutze den sks-Schlüsselserververbund statt eines einzelnen Servers und sichere Verbindungen

Ältere Versionen von OpenPGP haben einen einzelnen, spezifischen Schlüsselserver vorkonfiguriert. Das ist alles andere als ideal, denn falls der Server ausfällt oder - schlimmer noch - zu funktionieren scheint aber fehlerhaft ist, könnte es geschehen, dass Dir kritische Schlüsselaktualisierungen.

Deshalb empfehlen wir die Nutzung des [[sks-Schlüsselserververbundes -> https://sks-keyservers.net/overview-of-pools.php]]. Die Rechner in diesem Pool unterliegen regelmäßigen Tests, um sicherzustellen, dass sie fehlerfrei funktionieren. Funktioniert ein Server nicht gut, wird er automatisch aus dem Verbund entfernt.

Du solltest auch sicherstellen, dass Du mit dem Schlüsselserververbund verschlüsselt kommunizierst, mit einem Protokoll namens hkps. Um hkps nutzen zu können, musst Du zunächst gnupg-curl installieren (auf Debian/Ubuntu: @sudo apt-get install gnupg-curl@).

Um nun den Schlüsselserververbund nutzen zu können, musst Du das [[Sicherheitszertifikat von sks-keyservers.net herunterladen -> https://sks-keyservers.net/sks-keyservers.netCA.pem]] und an einem geeigneten Ort auf Deinem Rechner speichern. Bitte merke Dir, unter welchem Pfad Du die Datei ablegst! Nun solltest Du den [[Fingerabdruck des Zertifikats verifizieren -> https://sks-keyservers.net/verify_tls.php]]. Betrachte den X509v3 "Subject Key Identifier" Wert mit

bc. curl -sSL https://sks-keyservers.net/sks-keyservers.netCA.pem | openssl x509 -in - -noout -text | grep "X509v3 Subject Key Identifier" -A1 | tail -n1 | tr -d ' '

und vergleiche ihn mit X509-Fingerabdruck auf der [[Pool-Webseite-> https://sks-keyservers.net/verify_tls.php]]. Dort gibt es eine Signatur, um die .pem-Datei zu verifzieren:

bc. curl -sSL https://sks-keyservers.net/sks-keyservers.netCA.pem -o sks-keyservers.netCA.pem
curl -sSL https://sks-keyservers.net/sks-keyservers.netCA.pem.asc -o sks-keyservers.netCA.pem.asc
openssl verify -trusted sks-keyservers.netCA.pem -check_ss_sig sks-keyservers.netCA.pem

Die Ausgabe sollte sein: @sks-keyservers.netCA.pem: OK@. Siehe auch [[Dateisignaturen überprüfen -> https://www.torproject.org/docs/verifying-signatures.html.de]].

Um sicherzustellen, dass das Zertifikat korrekt herunter geladen wurden, vergleiche die OpenPGP-Signatur:

bc. gpg --auto-key-retrieve --verify sks-keyservers.netCA.pem.asc

Die Option [[@--auto-key-retrieve@ -> https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#GPG-Configuration-Options]] importiert automatisch Schlüssel, die zum Erzeugen der Signatur verwendet wurden. Die Ausgabe sollte so aussehen:

bc. gpg: die unterzeichneten Daten sind wohl in 'sks-keyservers.netCA.pem'
gpg: Signatur vom Mi 30 Mär 2016 17:06:29 CEST
gpg:                mittels RSA-Schlüssel 0x250B7AFED6379D85
gpg: Korrekte Signatur von "Kristian Fiskerstrand <kristian.fiskerstrand@sumptuouscapital.com>" [unbekannt]
gpg:                     alias "Kristian Fiskerstrand <kf@gnupg.net>" [unbekannt]
gpg:                     alias "Kristian Fiskerstrand <k_f@gentoo.org>" [unbekannt]
gpg:                     alias "Kristian Fiskerstrand <kf@sumptuouscapital.com>" [unbekannt]
gpg: WARNUNG: Dieser Schlüssel trägt keine vertrauenswürdige Signatur!
gpg:          Es gibt keinen Hinweis, daß die Signatur wirklich dem vorgeblichen Besitzer gehört.
Haupt-Fingerabdruck  = 94CB AFDD 3034 5109 5618  35AA 0B7F 8B60 E3ED FAE3
Unter-Fingerabdruck  = B4EA D120 C7F8 9A4A EA47  2707 250B 7AFE D637 9D85

Wenn Du diese Nachricht siehst, ist sicher, dass Deine Kopie des Zerifikats korrekt ist. Da Dir das gelungen ist, kannst Du nun auch [[das Zertifikat von Riseup überprüfen->certificates]].

Wenn das geschehen ist, solltest Du die folgenden Parameter in @~/.gnupg/gpg.conf@ eintragen und dabei den vollständigen Pfad angeben, unter dem Du die .pem-Datei oben abgelegt hast:

pre.. keyserver hkps://hkps.pool.sks-keyservers.net
keyserver-options ca-cert-file=/pfad/zur/Datei/sks-keyservers.netCA.pem

Hinweis: GnuPG 2.1 zeigt eine Warnung, wenn diese Option verwendet wird:
@gpg: keyserver option 'ca-cert-file' is obsolete; please use 'hkp-cacert' in dirmngr.conf@

Verwende stattdessen die [[dirmngr-Option 'hkp-cacert'->https://www.gnupg.org/documentation/manuals/gnupg/Dirmngr-Options.html#Dirmngr-Options]].

p. Von jetzt an werden Deine Interaktionen mit dem Schlüsselserver über hkps verschlüsselt, so dass Deine Sozialprofil jedem verborgen bleibt, der vielleicht Deinen Datenverkehr abhört. Wenn Du beispielsweise @gpg --refresh-keys@ eingibst und einen Schlüsselserver benutzt, der nur hkp unterstützt, dann wird jemand, der Deine Daten abfängt, jeden einzelnen Schlüssel in Deinem Schlüsselbund zu sehen bekommen, während Du die Schlüsselupdates anforderst. Das sind ziemlich interessante Informationen.

h3. Sicherstellen, dass alle Schlüssel über den Schlüsselserver aktualisiert werden, den Du angegeben hast

Bei der Schlüsselerzeugung können die Besitzer*innen einen bestimmten Schlüsselserver angeben, von dem ihr Schlüssel zu beziehen ist. Es ist ratsam, die folgende Option in @~/.gnupg/gpg.conf@ einzutragen, um solche Zuordnungen zu ignorieren:

pre. keyserver-options no-honor-keyserver-url

Das ist sinnvoll, weil es 1) verhindert, dass irgendwer eine unsichere Methode angibt, um ihren Schlüssel herunterzuladen und 2) weil die Aktualisierung von einem Server, der hkps verwendet, scheitern wird, da das Sicherheitszertifikat nicht mit dem des Servers übereinstimmt, so dass die Schlüssel niemals aktualisiert werden. Auch könnte ein Angreifer einen Schlüsselserver unter eigener Kontrolle angeben, um zu überwachen wann oder von wo der Schlüssel aktualisiert wird.

@gpg --keyserver-options no-honor-keyserver-url --refresh-keys@ ist die gleicheis the equivalent to set this option every time you perform key updates.

h3. Schlüssel langsam und einzeln aktualisieren

Nun, da Du einen guten Schlüsselserver konfiguriert hast, solltest Du sicherstellen, dass Deine Schlüssel regelmäßig aktualisiert werden.

Der Befehl @gpg --keyserver-options no-honor-keyserver-url --refresh-keys@ benutzt obige Einstellung, aber du solltest ihn nicht verwenden (genau so wenig wie die Menüoption 'Schlüssel aktualisieren' in Deinem Emailprogramm), denn damit gibst gegenüber dem Schlüsselserver alle Adressen preis, die Du aktualiseren möchtest. Die [[gnupg Dokumentation -> https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#GPG-Configuration-Options]] schreibt zu @--auto-key-retrieve@:

bq. Diese Option ermöglicht "Web-Wanzen", denn Schlüsselserver oder Operatoren eines Web Key Directory können sehen, welche Schlüssel angefordert werden. Indem sie eine mit einem brandneuen Schlüssel signierte Nachricht versenden (der erwartungsgemäß noch in keinem Schlüsselbund ist), kann der Operator sehen, von welcher IP-Adresse und zu welcher Zeit die Signatur verifziert wurde.

Daher ist es gut, [[GnuPG-Anfragen per Tor zu versenden -> https://trac.torproject.org/projects/tor/wiki/doc/TorifyHOWTO/GnuPG]]: Überprüfe, dass @use-tor@ in @~/.gnupg/dirmngr.conf@ steht (standarmäßig seit GnuPG v2.1).

Bis GnuPG [[diese Option -> https://dev.gnupg.org/T1235]] anbietet, kannst Du folgendes Skript in Cronjobs verwenden:

.bc #!/bin/bash
# refreshes gpg keys one by one with a random time interval
while true
do
  for fingerprint in $(gpg --list-keys --with-colons --with-fingerprint | grep --after-context "1" "^pub" | grep "^fpr" | cut -d ":" -f "10" | sort --random-sort)
  do
    sleep $(( (RANDOM % 1000) + 300))
    gpg --batch --no-tty --no-auto-check-trustdb --refresh-keys "$fingerprint" 2> /dev/null
  done
done &

h4. Probleme mit dirmngr

Wenn Du den Eindruck hast, dass die Antwort "No data" ("Keine Daten") beim Suchen nach Schlüssel (@gpg --search KEYID@) falsch ist, führe @dirmngr --shutdown@ aus. Das kann beliebig oft wiederholt werden, denn dirmngr wird automatisch gestartet, wenn er gebraucht wird.

Bei dem Fehler 'error: searching keyserver: server indicated a failure', start tor, dirmngr and gpg-agent neu (@KILLAGENT@ an @gpg-connect-agent@ schicken). Dann sollte es wieder normal funktionieren.

Es gibt bekannte Probleme mit der enthaltenen libdns, die kürzlich behoben wurden und ab v2.2.9 ausgeliefert werden.

Um ihn neuzustarten: Starte die interaktive Schnittstelle von @gpg-connect-agent@, gib @KILLAGENT@ ein und drücke Strg-D, um ihn zu stoppen. Auf Debian-basierten System kannst Du ihn mit @systemctl --user restart dirmngr.socket@ und @gpgconf --kill gpg-agent@ neustarten.

h3. Schlüsseln von Schlüsselservern nicht blind vertrauen

Jede*r kann Schlüssel auf einen Schlüsselserver hochladen und es gibt keinen Grund anzunehmen, dass der Schlüssel, den Du herunterlädst, tatsächlich der Person gehört, die im Schlüssel angegeben wird. Deshalb solltest Du den vollständigen Fingerabdruck des Schlüssels mit der Eigentümer*in des Schlüssels verifizieren und zwar bei einem persönlichen Treffen oder am Telefon.

Sobald Du den gesuchten Fingerabdruck mit der Eigentümer*in verifiziert hast, kannst Du den Schlüssel über den Fingerabdruck vom Schlüsselserververbund herunterladen:

bc. gpg --recv-key '<fingerprint>'

Beachte die einfachen Anführungsstriche oben ('), welche vor und hinter dem vollständigen Fingerabdruck stehen sollten und notwendig sind, damit dieser Befehl funktioniert. Doppelte Anführungszeichen oben (") gehen auch.

Der nächste Schritt ist, sicherzustellen, dass du tatsächlich den richtigen Schlüssel bekommen hast. Der Schlüsselserver könnte dir einen anderen geschickt haben, als den den du wolltest. Wenn Du gpg mit einer Version kleiner als 2.1 benutzt, musst du den Fingerabdruck manuell nach dem Herunterladen überprüfen (Version 2.1 und neuer lehnen Schlüssel vom Schlüsselserver mit falschem Fingerabdruck ab).

Es gibt zwei Möglichkeiten, den Fingerabdruck zu überprüfen:

Option 1. Überprüfe, dass der Fingerabdruck jetzt in deinem Schlüsselbund vorhanden ist:

bc. gpg --fingerprint '<fingerprint>'

Option 2. Versuche (lokal) einen Schlüssel mit diesem Fingerabdruck zu signieren:

bc. gpg --lsign-key '<fingerprint>'

Wenn du sicher bist, dass du den richtigen Fingerabdruck von der Person hast, welcher der Schlüssel gehört, ist die bevorzugte Methode, den Schlüssel lokal zu signieren.
Wenn du öffentlich deine Beziehung zu dieser Person bewerben willst, kannst du auch das öffentlich exportierbare [@--sign-key@] verwenden.

h3. Verlasse Dich nicht auf die Schlüssel-ID (keyid).

Kurze OpenPGP Schlüssel-IDs, beispielsweise 0x2861A790, sind 32 bit lang. Es ist [[bekannt -> https://www.asheesh.org/note/debian/short-key-ids-are-bad-news.html]], dass es leicht ist einen neuen, gefälschten Schlüssel mit der selben Schlüssel-ID zu erstellen. Lange OpenPGP Schlüssel-IDs (wie z.B. 0xA1E6148633874A3D) sind 64 bit lang. [[ID-Kollisionen herbeizuführen ist trivial -> http://thread.gmane.org/gmane.ietf.openpgp/7413]], was ebenfalls [[ein potentiell ernsthaftes Problem darstellt -> https://www.debian-administration.org/users/dkg/weblog/105]].

Wenn Du wirklich eine kryptographisch starke Identifikation für einen Schlüssel haben willst, solltest Du den vollen Fingerabdruck verwenden. Du solltest Dich _nie_ auf die Schlüssel-ID verlassen, weder die kurze, noch die lange.

Du solltest wahrscheinlich mindestens die GnuPG-Optionen @keyid-format 0xlong@ und @with-fingerprint@ verwenden (trage sie in @~/.gnupg/gpg.conf@ ein) um die Anzeigenlänge der Schlüssel-ID auf 64 bit zu verlängern und immer den Fingerabdruck anzuzeigen.

Anmerkung: Es gab einen [[Bug in Enigmail -> https://sourceforge.net/p/enigmail/bugs/239/]], der seit Version 1.7.0 behoben ist: Wenn Du die Option 'with-fingerprint' einsetzt, um bei der Anzeige der Schlüssel immer den vollständigen Fingerabdruck mit auszugeben, wird im Schlüsselverwaltungsfenster von Enigmail der Fingerabdruck eines Unterschlüssels (subkey) angezeigt und nicht der des primären Schlüssels. Du kannst immer den Fingerabdruck Deines primären Schlüssels finden (z.B. wenn Du jemandem auf einer Keysigning-Party Deinen Fingerabdruck zur Verifikation geben möchtest), indem Du die Fingerabdrücke all Deiner geheimen Schlüssel mit dem folgenden Kommando anzeigen lässt:

pre. gpg --with-fingerprint --list-secret-key

Nun da Du weisst, wie Du reguläre Schlüsselaktualisierungen von einem gut gewarteten Schlüsselserver abrufen kannst, solltest Du Dich vergewissern, dass Dein OpenPGP-Schlüssel optimal konfiguriert ist. Viele dieser Änderungen werden das Generieren eines neuen Schlüssels erforderlich machen.

h2. Schlüsselkonfiguration.

Nun da Du weisst, wie Du reguläre Schlüsselaktualisierungen von einem gut gewarteten Schlüsselserver abrufen kannst, solltest Du Dich vergewissern, dass Dein OpenPGP-Schlüssel optimal konfiguriert ist. Viele dieser Änderungen werden das Generieren eines neuen Schlüssels erforderlich machen. [[Weiterlesen -> gpg-keys#Schlüsselkonfiguration]]

h2. Zusätzliche Vorschläge.

h3. Benutze einen Unterschlüssel mit Elliptischen Kurven (ECC)

Seit GnuPG v2.1 werden ECC-Unterschlüssel unterstützt.

Sie sind schneller, was für Sicherheits-Tokens nützlich ist. Beachte, dass wenn ein Schlüssel RSA- und ECC-Unterschlüssel enthält, wird GnuPG den funktionieren auswählen (z.B. RSA, wenn ECC nicht unterstützt ist).

Für Details konsultiere die [[offizielle Hilfeseite->https://www.gnupg.org/faq/whats-new-in-2.1.html#ecc]].

h3. Hast Du ein verschlüsseltes Backup Deines geheimen Schlüsselmaterials?

Vergewissere Dich, dass es wirklich so ist.

h3. Verwende keinen "Kommentar" in Deiner Benutzer-ID

Wenn Du der Ansicht bist, dass Du einen "Kommentar" in Deiner OpenPGP Benutzer-ID benötigst, [[denke bitte lange und tief darüber nach, ob das wirklich nötig ist -> https://www.debian-administration.org/users/dkg/weblog/97]]. Wahrscheinlich brauchst und willst Du das gar nicht und ein Kommentar erschwert es anderen Leuten, festzustellen, was sie eigentlich zertifizieren.
