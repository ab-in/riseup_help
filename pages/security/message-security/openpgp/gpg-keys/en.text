@title = "Managing OpenPGP Keys"

This instruction will guide you step-by-step through creating OpenPGP public/private key pairs, exporting public keys to key servers, and finding OpenPGP public keys for secure communication with others.

h1. First step before start

First read the instructions in [[gpg-best-practices]] carefully to ensure your system generates a strong key and receives key updates from a well-maintained keyserver. This will require to make changes to the *gpg.conf* configuration file, which is located in different places depending on your operating system. In Linux it is located in @~/.gnupg/gpg.conf@.

h2. Autocrypt

To widen the use of OpenPGP opportunistic encryption for mails is in development under the name [[autocrypt -> https://autocrypt.org/index.html]]. Several [[mail clients]] like [[delta.chat -> https://delta.chat]] (android), [[enigmail]], [[K9mail]] and [[others->https://autocrypt.org/dev-status.html]] already implement it.

h1. Key configuration

h2. Use a strong primary key.

Some people still have 1024-bit DSA keys. You really should transition to a stronger bit-length and hashing algo. In 2011, the US government instution NIST has [[deprecated -> http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf]] DSA-1024, since 2013 it is even [[disallowed -> http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf]]. In 2015, NIST also [[disallowed -> https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf]] 1024-bit RSA, and use of SHA-1 for signing.

It is recommend to make a 3072-bit RSA key, with the sha512 hashing algo, making a [[transition statement -> key-transition]] that is signed by both keys, and then letting people know. Also have a look at this [[good document -> http://ekaia.org/blog/2009/05/10/creating-new-gpgkey]] that details *exactly* the steps that you need to create such a key, making sure that you are getting the right hashing algo (it can be slightly complicated if you are using GnuPG versions less than 1.4.10).

Transitioning can be painful, but it is worth it, and a good opportunity to practice with the tools!

h2. Use an expiration date less than two years.

People think that they don't want their keys to expire, but you actually *do*. Why? Because *you can always extend your expiration date, even after it has expired!* This "expiration" is actually more of a safety valve or "dead-man switch" that will automatically trigger at some point. If you have access to the secret key material, you can untrigger it. The point is to setup something to disable your key in case you lose access to it (and have no revocation certificate).

Setting an expiration date means that you will need to extend that expiration date sometime in the future. That is a small task that you will need to remember to do (see next item about setting a reminder).

You may think that is annoying and you don't want to deal with it, but it is actually good to be doing this on a regular basis so you keep your OpenPGP skills fresh. It indicates to users that their key is still active, and that the keyholder is using it, and gives you an opportunity to review the current state of your tools, and best practices. Also, many people will not sign a key that has no expiration date!

If you have already generated a key without an expiration date, you can set an expiration date on your key by doing the following:

bc. gpg --edit-key '<fingerprint>'

Now select the subkey for which you want to set an expiration date (e.g. the first one), or none to set the expiration on your primary key and then issue the 'expire' command:

bc. gpg> key 1
gpg> expire

p. Then set the date to a reasonable one, and save the key and exit (e.g. 2 years):

bc. Key is valid for? (0) 2y
gpg> save

p. Then you may send your key to the keyservers to publish this change:

bc. gpg --send-key '<fingerprint>'

h2. Set a calendar event to remind you about your expiration date

You won't remember, so its best to ask something to remind you. Set your reminder a month or more before the date so you can do the change with some time. You do not want to be rushed when you are dealing with your keys.

Remember: you can always extend your expiration date (even after it has expired!), so you do not need to make a brand new key, you just need to extend your expiration to a later time. Doing this on a regular basis is good to exercise your OpenPGP muscles, otherwise you will forget things.

h3. Generate a revocation certificate.

bc. [[Since gnupg 2.1 -> https://www.gnupg.org/faq/whats-new-in-2.1.html#autorev]] a revocation certificate is created automatically.

If you forget your passphrase or if your private key is compromised or lost, the only hope you have is to wait for the key to expire (this is not a good solution), or to activate your revocation certificate by publishing it to the keyservers. Doing this will notify others that this key has been revoked.

A revoked key can still be used to verify old signatures, or decrypt data (if you still have access to the private key), but it cannot be used to encrypt new messages to you.

bc. gpg --output revoke.asc --gen-revoke '<fingerprint>'

This will create a file called revoke.asc. You may wish to print a hardcopy of the certificate to store somewhere safe (give it to your mom, or put it in your offsite backups). If someone gets access to this, they can revoke your key, which is very inconvenient, but if they also have access to your private key, then this is exactly what you want to happen.

bq. Note that this is done by default in newer releases of GnuPG (e.g. 2.1 and above).

h3. Only use your primary key for certification (and possibly signing). Have a separate subkey for encryption.

This is done by default in GnuPG 1.4.18 (and maybe earlier) and above. If you created your key with older implementations of OpenPGP, you may need to create new subkeys like you would do for signing, below.

h2. Have a separate subkey for signing

By default GnuPG uses the same subkey for signing (e.g. signing an email message) and certifying (e.g. signing another key). It is useful to separate those purposes as one is way more important than the other.

In this scenario, your primary key is used only for certifications, which happen infrequently.

Creating a new subkey can be done in the @--edit-key@ dialog, using the @addkey@ command. During the dialog, you can choose the "capability" of the key...

h2. Keep your primary key entirely offline

bc. There are [[several -> https://github.com/flamsmark/documentation/blob/master/gpg/smartcard-keygen.md]] [[good -> https://www.void.gr/kargig/blog/2013/12/02/creating-a-new-gpg-key-with-subkeys/]] [[guides -> https://blog.josefsson.org/2014/06/23/offline-gnupg-master-key-and-subkeys-on-yubikey-neo-smartcard/]] on this topic. Below instructions have been written for gnupg 1.4 and may be outdated since 2.1

This is tricky to do but helps in protecting the very important primary key. If your primary key is stolen, the attacker can create new identities, revoke existing ones and completely impersonate you. Storing keys "offline" is therefore a good way to protect against such attacks.

Make sure you created a separate signing key before you do this, otherwise you will not be able to sign emails without your offline key.

Extracting the primary key is tricky, but this should get you going:

bc. # extract the primary key
gpg -a --export-secret-key john.doe@example.com > secret_key
# extract the subkeys, which we will reimport later
gpg -a --export-secret-subkeys john.doe@example.com > secret_subkeys.gpg
# *delete* the secret keys from the keyring, so only subkeys are left
$ gpg --delete-secret-keys john.doe@example.com
Delete this key from the keyring? (y/N) y
This is a secret key! - really delete? (y/N) y
# reimport the subkeys
$ gpg --import secret_subkeys.gpg
# verify everything is in order
$ gpg --list-secret-keys
# remove the subkeys from disk
$ rm secret_subkeys.gpg

Then you want to put the @secret_key@ file offline, probably on a thumb drive that you always carry with you, or in a guarded safe. Others will use smartcards to store the key and keep them with their physical keyring. The security of that device will be the security of your key.

Again, make sure you have a revocation certificate.

You can make sure the secret key material is missing by running @--list-secret-keys@ which should make the missing material with a @sec#@ instead of just @sec@.

Note: in certain exotic situations, @--delete-secret-keys@ may not completely remove the secret key material and @--list-secret-keys@ will still show @sec@ instead of @sec#@. In this case, you can move the @.gnupg@ directory out of the way instead of running @--delete-secret-keys@. You will need to reimport your trustdb and public keys of course, which will look something like this:

bc. instead of gpg --delete-secret-keys john.doe@example.com, do this:
$ mv .gnupg .gnupg.bak
# reimport the subkeys
$ gpg --import secret_subkeys.gpg
# verify everything is in order
$ gpg --list-secret-keys
# remove the subkeys from disk
$ rm secret_subkeys.gpg
# reimport public keyring
$ gpg --homedir .gnupg.bak --export | gpg --import
# reimport trust db
$ gpg --homedir .gnupg.bak --export-ownertrust | gpg --import-ownertrust
# remove backup GPG directory, which will clear *all* secret keys
$ rm -rf .gnupg.bak

Finally note that in the above manipulations, secret key material is stored in the clear on disk. You may want to securely delete those files (using, for example, @nwipe@) instead of using the simple @rm@ to remove private key material. Do consider that modern disks like SSDs run advanced firmware that may not really obey such commands and leave traces of private key material on disk. The best defense, in this case, is to use Full Disk Encryption.

Note that those procedures may change from version to version. See [[this discussion -> http://security.stackexchange.com/questions/31594/what-is-a-good-general-purpose-gnupg-key-setup]] or [[this article -> https://www.paulfurley.com/gpg-for-humans-protecting-your-primary-key/]], or [[this guide -> https://incenp.org/notes/2015/using-an-offline-gnupg-master-key.html]] designed for GnuPG 2.x and above.

h2. OpenPGP key checks.

There is a handy tool that will perform the key checks below for you. You can get it [[from the source -> http://floss.scru.org/hopenpgp-tools/]], or if you are running Debian or Ubuntu, you can install the package directly by doing:

bc. sudo apt-get install hopenpgp-tools

Note: @hopenpgp-tools@ currently does not work with GnuPG version 2.1 and up. This is because GnuPG version 2.1 and up store both your public and private key in @~/.gnupg/pubring.kbx@. @hkt@ expects to find your public key in @~/.gnupg/pubring.gpg@ and will give an error message if you are using GnuPG version 2.1 and up.

To run these tests with the tool, you can do the following:

bc. hkt export-pubkeys '<fingerprint>' | hokey lint

The output will display any problems with your key in red text. If everything is green, your key passes each of the tests below. If it is red, your key fails one of the tests listed below and you should fix it or generate a new key after ensuring that your @gpg.conf@ is set up as recommended.

h3. Make sure your key is OpenPGPv4

According to [[RFC4880 -> https://tools.ietf.org/html/rfc4880]]: "V3 keys are deprecated. They contain three weaknesses. First, it is relatively easy to construct a V3 key that has the same Key ID as any other key because the Key ID is simply the low 64 bits of the public modulus. Secondly, because the fingerprint of a V3 key hashes the key material, but not its length, there is an increased opportunity for fingerprint collisions. Third, there are weaknesses in the MD5 hash algorithm that make developers prefer other algorithms. See below for a fuller discussion of Key IDs and fingerprints"

To determine if your key is a V3 key you can do the following:

bc. gpg --export-options export-minimal --export '<fingerprint>' | gpg --list-packets |grep version

h3. primary keys should be RSA, ideally 3072 bits.

To check if you are using RSA, you can do this:

bc. gpg --export-options export-minimal --export '<fingerprint>' | gpg --list-packets | grep -A2 '^:public key packet:$' | grep algo

If the reported algorithm is 1, you are using RSA.

 If it is 17, then it is DSA and you will need to confirm that the size reported in the next check reports a bit-length key size greater than 1024, otherwise you aren't using DSA-2.

If the reported algorithm is 19, you are using ECDSA, if it is 18 you are using ECC, and the key bit-length determination check below is not an appropriate criteria for these types of keys as as the key sizes will drop significantly.

To check the bit-length of the primary key you can do this:

bc. gpg --export-options export-minimal --export '<fingerprint>' | gpg --list-packets | grep -A2 'public key' | grep 'pkey\[0\]:'

h3. self-signatures should not use MD5 exclusively

You can check this by doing:

bc. gpg --export-options export-minimal --export '<fingerprint>' | gpg --list-packets | grep -A 2 signature | grep 'digest algo'

If you see any 'digest algo 1' results printed, then you have some self-signatures that are using MD5, as digest algo 1 is MD5. See the [[OpenPGP RFC 4880, section 9.4 -> https://tools.ietf.org/html/rfc4880#section-9.4]] for a table that maps hash algorithms to numbers.

To fix this, first, you should set the following in your @~/.gnupg/gpg.conf@:

bc. cert-digest-algo SHA512

Second, you should generate a new self-signature on your key (e.g. [[by changing the key's expiration date -> gpg-keys#use-an-expiration-date-less-than-two-years]]).

h3. self-signatures should not use SHA1

You can check this by doing:

bc. gpg --export-options export-minimal --export '<fingerprint>' | gpg --list-packets | grep -A 2 signature | grep 'digest algo 2,'

If you see any 'digest algo 2' results printed, then you have some self-signatures that are using SHA1, as digest algo 2 is SHA1. See the [[OpenPGP RFC 4880, section 9.4 -> https://tools.ietf.org/html/rfc4880#section-9.4]] for a table that maps hash algorithms to numbers.

To fix this, you can generate a new self-signature on your key (e.g. [[by changing its expiration date -> gpg-keys#use-an-expiration-date-less-than-two-years]]) after setting the following in your @~/.gnupg/gpg.conf@:

bc. cert-digest-algo SHA512

h4. stated digest algorithm preferences must include at least one member of the SHA-2 family at a higher priority than both MD5 and SHA1

bc. Note: Since gnupg 2.2.0-3 these settings are default and don't need to be changed manually anymore.

You can check this by doing:

bc. gpg --export-options export-minimal --export '<fingerprint>' | gpg --list-packets | grep 'pref-hash-algos'

and then inspect the results. The preference order is based on which number comes first from left to right. If you see the number '3', '2', or '1' before you see '11', '10', '9' or '8', then you have specified your preferences to favor a weakened digest algorithm

To fix this, first set the following in your @~/.gnupg/gpg.conf@:

bc. default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed

then set the preferences on your key like this:

bc. $ gpg --edit-key '<fingerprint>'
gpg> setpref
...
gpg> save

h3. primary keys should have a reasonable expiration date (no more than 2 years in the future)

You can check what your expiration dates are by doing this:

bc. gpg --export-options export-minimal --export '<fingerprint>' | gpg --list-packets | grep 'key expires after'

Then visually inspect what the results are to confirm this -- the date listed will be relative to key creation, though, which can be difficult to interpret.

Another way to check expiration is just to do:

bc. gpg --list-keys '<fingerprint>'

which should show the creation and expiration dates of the primary key and each associated subkey. If you don't see anything that says "expires" in this output, then you have not set an expiration date properly.

To fix this, you can do:

bc. $ gpg --edit-key '<fingerprint>'
gpg> expire
...
gpg> save

h1. Linux

h2. Using GNOME's GUI frontend: Seahorse

h3. What is Seahorse?

"Seahorse":https://en.wikipedia.org/wiki/Seahorse_(software) is a GUI tool for creating and managing OpenPGP keys, securely storing passwords, and creating and managing SSH certificates. It uses GPG as the back-end OpenPGP implementation.

h3. Create and export an OpenPGP Public/Private Key pair

# Launch Seahorse. It should be installed by default.
# Select GnuPG keys.
# Select the + sign to create a new key.
# Select PGP Key.
# Enter your email and the name you would like to be associated with the key. This doesn't need to be your real name.
# Select advanced options.
# Encryption type should be RSA.
# Key strength should be 3072.
# Expiration date should be within less then two years. *You can always extend the key expiration as long as you still have access to the key, even after it has expired.* [[Why should I set an expiration --> gpg-keys#use-an-expiration-date-less-than-two-years]].
# Enter a **strong** password that you can remember. **If you forget this password, it cannot be recovered and any encrypted data you have using it for, including emails, will be permanently inaccessible.**
# The computer will now generate the key, which may take some time. After this, you will have an OpenPGP key pair that is ready to be used--Great! You can manage the key options, export the public key, change the password, delete and/or revoke the key, and perform other key adjustments through the Seahorse user interface or the command line.
# **Optional:** At this point, you can publish your public key to a key server where people can request it remotely to be able to send encrypted data and emails to you. Before you continue, please make sure you have [[selected a good keyserver -> /gpg-best-practices#selecting-a-keyserver-and-configuring-your-machine-to-refresh-your-keyring]]. Once you are ready:
## Select the Key(s) you want to publish. Hold Ctrl and click to select more than one, or press **Ctrl+A** to select all keys.
## Navigate to **Remote** -> **Sync and Publish Keys...**
## Press the **Key Servers** button.
## Publish the keys to any keyserver (select one if the "Sync" button was grayed out in the previous screen); they all synchronize with each other, so your key will be on each one.
## **Recommended:** Check the **Automatically retrieve keys from key servers** but *do not check* the **Automatically synchronize modified keys with key servers** check boxes. Instead, please consider [[using parcimonie -> /gpg-best-practices#refresh-your-keys-slowly-and-one-at-a-time]]. 
## Press the **Close** button and then the **Sync** button to synchronize your keys.

Your public key is now published on the key servers and is accessible to others!

h3. Find or import someone else's OpenPGP Public Key

If you want to communicate with others securely or encrypt data that only they can read, you first need to import their public key into your keyring. **Note:** The John Q. Alias key is used as an example key for generating a key above and also for importing a key below; in the case of importing, it is used to refer to the person for whom you're searching, not yourself.

h4. Import from a key file

If someone exports their key to a file and sends it to you, you can import it into your keyring via Seahorse by:
# Navigating to **File** -> **Import...**
# Locate where you saved the key file, selecti it, and pressi the **Open** button.

The key that was stored in the key file has now been imported into your keyring!

h4. Searching on keyservers

# Navigate to **Remote** -> **Find Remote Keys...** in Seahorse
# Type some key words (a name or alias) to search the key servers. The best way to find someone is to search for their email address, as it's uniquely tied to them.
# Select and review the keys that are returned to determine whether the key(s) returned belong to the person you're looking for. You can review additional information about the key by pressing the **Properties** button.
# Once you've determined and selected the key(s) you want to import into your local keyring, press **Import**.

Their public key has now been imported into your keyring!

h3. Verifying a key

Anyone can publish a key on a keyserver. For example, for a fun trick, try searching for Edwards Snowden's key. There are many, many keys! Before you start using a key, you should verify the key's fingerprint with the individual with whom you wish to communicate. *You should not do this by email!* The best practice is to verify the fingerprint in person. At a minimum, you should use voice/video to confirm that you have the right key. To verify the fingerprint, you can use the following steps:

# Open seahorse
# On the view menu, select *show any*
# Locate the key that you have already imported
# Select *properties* (right click)
# Select *details*
# Confirm with the key's owner that the fingerprint listed is correct

After you have carefully reviewed the fingerprint and verified its accuracy with the owner of the key, you may sign their key with your key. To do this:

# From the same window as above, select the **Trust** tab and press the **Sign this key** button.
# Sign the key, indicating how carefully you've checked the key. Selecting **Not at all** still allows you to use the key for email and data. You can also opt to be able to revoke your signature later or make it so that only you can see that you've signed the key.
# Press **Sign**.

You can now begin encrypting data that can only be decrypted by the key owner and establish a secure communication line between you and the key owner!

h2. Use Enigmail to encrypt your mails

See our [[Enigmail]] guide.

h2. Using the Linux command line

This is based on the "Ubuntu GPG Howto":https://help.ubuntu.com/community/GnuPrivacyGuardHowto

h3. Ensure that you have already set the right defaults

Please first review the [[gpg-best-practices]] guide to ensure that you have set your defaults correctly. *Do this before proceeding!*

h3. Generate an OpenPGP Key pair using GPG

Press **Alt+F2** and type: @gnome-terminal@ and then press enter

In the terminal, type: @gpg --gen-key@
which should return a menu similar to this:

bc. Please select what kind of key you want:
  (1) RSA and RSA (default)
  (2) DSA and Elgamal
  (3) DSA (sign only)
  (4) RSA (sign only)

Select the type of key you want. **RSA and RSA** is the recommended type. **(sign only)** keys cannot be used for encryption.

Next, enter the key size you want. **3072** is recommended.

bc. What keysize do you want? (2048)

Then enter the length of time that you would like the key valid for and then press **y** to confirm the expiration date. If you select 0, the key does not expire and will require to be revoked when you no longer wish to use it. [[It is recommended --> #use-an-expiration-date-less-than-two-years]] to have your key expire within no more than 2 years.


bc. Please specify how long the key should be valid.
     0 = key does not expire
   <n> = key expires in n days
   <n>w = key expires in n weeks
   <n>m = key expires in n months
   <n>y = key expires in n years
Key is valid for? (0)

Enter your name, email address. [[It is not recommended to use a comment -> /gpg-best-practices#do-not-include-a-comment-in-your-user-id]]. Your name and email address can be anything you want, not necessarily your real name or email address. If you want to use your OpenPGP key for encrypting email, put the email address you want to use with encryption in the "Email address" prompt.

bc. You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
  "Heinrich Heine (Der Dichter) <heinrichh@duesseldorf.de>"
Real name: John Q. Alias
Email address: the-email-youre-going-to-use@whatever.tld
Comment:

Now enter a **strong** password that you can remember. **If you forget this password, it cannot be recovered and any encrypted data you have using it, including emails, will be permanently inaccessible.** Hit enter when complete to begin generating the key.

Your OpenPGP public/private key pair has been generated!

h3. List your keys

You can use this command to list your keys:
@gpg --list-secret-keys@

This should output data in a format like this:

bc. sec   4096R/0xE361D8GH916EFH89 2014-05-14 [expires: 2016-05-14]
      Key fingerprint = 1234 5678 90AB CDEF GH01  2344 5678 9012 ABCE FGH1
uid                            John Q. Alias <the-email-youre-going-to-use@wherever.tld>
ssb   4096R/0x40339E25E2F2D99E 2014-05-14

p. Any reference to your **KEY-ID** below can be found using the first command and looking at the output. The line you're looking at to find the **KEY-ID** is the **sec** line of each of the entries). The line contains sec, the key strength and type abbreviation (**4096R** in the first line), a slash, the **KEY-ID**, and then the creation date. The codebox below highlights the **KEY-ID**:

bc. sec   4096R/0xE361D8GH916EFH89 2014-05-14 [expires: 2016-05-14]
            ^KEY-ID^
      Key fingerprint = 1234 5678 90AB CDEF GH01  2344 5678 9012 ABCE FGH1
uid                            John Q. Alias <the-email-youre-going-to-use@wherever.tld>
ssb   4096R/0x40339E25E2F2D99E 2014-05-14

p. So for this example, the **KEY-ID** would be **E361D8GH916EFH89**.

However, [[as discussed here -> /gpg-best-practices#dont-rely-on-the-key-id]] you should not rely on the keyid! Instead, you should use your *full fingerprint* for all operations.

h3. Export/Publish your public OpenPGP Key

# Press **Alt+F2** and run @gnome-terminal@
# Create an ASCII armored version of your public key for exporting by typing:
@gpg --export -a <<fingerprint>> > mykey.asc@

You've just exported your ASCII armored OpenPGP public key to the file **mykey.asc** in the folder you were in (your home directory, if you opened a new terminal). Now you can send the key to whomever you want to be able to encrypt files to you.

h3. Publish your OpenPGP public key to a Key server

At this point, you can publish your public key to a key server where people can request it remotely to be able to send encrypted data and emails to you.
# Press **Alt+F2** and run: @gnome-terminal@
# type @gpg --send-keys <<fingerprint>>@
where <<fingerprint>> is the fingerprint of the key you wish to publish on the key servers. Hopefully, you have already [[configured a good keyserver -> /gpg-best-practices#selecting-a-keyserver-and-configuring-your-machine-to-refresh-your-keyring].

h1. Windows

*The windows version of this guide is out-of-date. If you are a windows user, you can help us update it! Please see [[our github repository for our help pages to learn how -> https://github.com/riseupnet/riseup_help]]*

It is **not recommended** to use Windows as a secure communication platform. While Windows can be locked down to provide a more secure environment than is provided by default, the tendencies in Windows lean towards very lax security. There is also a multitude of pre-built exploits for windows that make it easier for attackers to compromise. Here are some bullet points against using windows for secure communications:
* widespread distribution of malware/trojans/viruses that could log key strokes, bypassing encryption schemes and/or logging other information
* targeted hacking and malware installation is actively used by governmental agencies with Microsoft being most susceptible
* Usually uses an unencrypted filesystem, main encryption tool is proprietary and cannot be scrutinized for exploits, back doors, or other weaknesses.
* User accounts are administrators by default
* Since Windows is proprietary and closed-source, there is no outside scrutiny for defects, back doors, or anything that "phones home". You're trusting Microsoft completely with whatever secrets you choose to put on your computer.

To ensure a secure communications platform, it's recommended to install a "GNU":https://www.gnu.org "Linux":https://www.gnu.org/gnu/linux-and-gnu.html "free software":https://www.gnu.org/philosophy/free-system-distribution-guidelines.html "distribution":https://distrowatch.com, like *"Debian":https://www.debian.org/distrib (recommended)*, "Ubuntu":https://www.ubuntu.com/download/desktop ("beware privacy issues":https://www.gnu.org/philosophy/ubuntu-spyware.en.html) or a derivate.

h2. Install Gpg4win

"Gpg4win":https://www.gpg4win.org is the recommended OpenPGP implementation for windows. It is Free Software, licensed under the GPL, with the source code available for modification or scrutiny.

# Download "Gpg4win":https://www.gpg4win.org/download.html
# Double click the executable and begin the installation.
# Select the language you'll be using.
# You'll be greeted by the welcome screen. Press **Next** to continue.

!img/gpg4win1-install-welcome.gif!

# Next, you'll be asked to agree to the [[GNU General Public License -> https://en.wikipedia.org/wiki/General_Public_License]] (the GPL license), which can be read in its entirety at [[GNU.org -> https://www.gnu.org/licenses/gpl.html]]. If you accept, press **Next**.
# Choose the components you want to install. The default options are recommended. [[Claws-Mail -> https://en.wikipedia.org/wiki/Claws_Mail]] is a powerful cross-platform email client available for Linux, Windows, Mac OS X, and others. GpgOL installs the plugin necessary to use OpenPGP keys with the Outlook mail client.

!img/gpg4win2-components.gif!

# Select the install folder (the default is recommended).
# Choose what shortcuts to create.
# Choose a name for any shortcut folders and then begin the installation. Choose to view the README file, or not, and then click finish.

Gpg4win is now installed and ready to use!

h2. Create and Export an OpenPGP Public/Private Key pair

Kleopatra seems to be the more recent and more polished of the two Gpg4win key manager GUI frontends on Windows, so this guide recommends using that.
# Launch Kleopatra by the shortcut you installed (default: **Start** -> **All Programs** -> **Gpg4win** -> **Kleopatra**)
# Click **File** -> **New Certificate...** or **Ctrl+N**.
# Press the **Create a personal OpenPGP key pair** button.
# Enter your name, email address, and a comment if you wish. Your name and email address can be anything you want, not necessarily your real name or email address. If you want to use your OpenPGP key for encrypting email, put the email address you want to use with encryption in the "Email address" box. When finished, click the **Advanced Settings...** button.

!img/kleopatra1-name-email-advanced.gif!

# In the **Advanced Settings...** dialog box, choose your key type and key strength. **RSA**, using key strength of **4,096 bits**, for **Signing** and **Encryption** are recommended. When finished with the key settings, press **OK** to close the dialog box, then click **Next**.
# Review the information for the key, then press the **Create Key** button.
# Enter a **strong** password that you can remember. The password strength meter will give you a relative indication of how strong the password is. Getting 100% **is strongly recommended**. **If you forget this password, it cannot be recovered and any encrypted data you have using it, including emails, will be permanently inaccessible.**

Your key pair is now finished! From here, you can do one of the following:
* Make a backup copy of your certificate (key)
* Send the Certificate by email
* Upload the certificate to a Directory Service (key server)
* finish the wizard

It is recommended to upload the certificate to a directory service. This will upload your public key to a key server where it can be used by others to encrypt data and emails that only you can decrypt.

h3. Find or Import someone else's OpenPGP Public Key

If you want to be able to communicate with someone securely or encrypt data that only they can read, you need to import their public key into your keyring first.

h4. Import from a key file

If someone exports their key to a file and sends it to you, you can import it into your keyring via Kleopatra by:
# Pressing the **Import Certificates** button, then
# Locating where you saved the key file, selecting it, and pressing the **Open** button.

The key that was stored in the key file has now been imported into your keyring!

h4. Find on the key servers

# Navigate to **File** -> **Lookup Certificates on Server...** in Kleopatra
# Type some key words (a name or alias) to search the key servers. The best way to find someone is to search for their email address, as it's uniquely tied to them.
# Select and review the keys that are returned to determine whether the key(s) returned belong to the person you're looking for. You can review additional information about the key by pressing the **Details...** button.
# Once you've determined and selected the key(s) you want to import into your local keyring, press **Import**.

Their public key has now been imported into your keyring! Once you have verified the fingerprint (see above about why this is important), you may sign the key.

h3. Sign their key (Certify their Certificate)

To do this,
# Click the **Imported Certificates** or **Other Certificates** tab.
# Right click the key you want to sign and click **Certify Certificate...**
# Select the user ID you want to certify and press **Next**
# Choose whether you want this certification to be visible to others or only to yourself and then press the **Certify** button.

You have now signed their key (certified their certificate) and are ready to begin encrypting data or emails that only they can decrypt!

h2. Use Enigmail to encrypt your mails

See our [[Enigmail]] guide.

h1. Mac OS X

*Unfortunately we have no MacOS version of this guide. If you are a MacOS user, you can help us update it! Please see [[our github repository for our help pages to learn how -> https://github.com/riseupnet/riseup_help]]*

It is **not recommended** to use Mac OS X as a secure communication platform. While there are fewer exploits and a better security model than windows, OS X has demonstrated a poor security patch speed in the past and has a large quantity of proprietary software and packaging, making it not capable of scrutiny for efects, back doors, or anything that "phones home". Furthermore, it offers features that can be exploited by hackers or abused by governments or corporations. Some bullet points about OS X security:
* Relies on a lot of proprietary software that can't be modified or scrutinized by you
* The webcam can be remotely turned on, offered as a "feature" if the laptop gets stolen, which could be abused or exploited to violate your privacy
* Filesystem not encrypted by default and the primary tool available "may have inadequate security":https://en.wikipedia.org/wiki/FileVault#Criticism.

To ensure a secure communications platform, it's recommended to install a "GNU":https://www.gnu.org "Linux":https://www.gnu.org/gnu/linux-and-gnu.html "free software":https://www.gnu.org/philosophy/free-system-distribution-guidelines.html "distribution":https://distrowatch.com, like *"Debian":https://www.debian.org/distrib (recommended)*, "Ubuntu":https://www.ubuntu.com/download/desktop ("beware privacy issues":https://www.gnu.org/philosophy/ubuntu-spyware.en.html) or a derivate.
